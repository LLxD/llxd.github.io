<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Resumo S.O</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="b24d6ec4-157e-4030-95ed-bb668ae18cc6" class="page sans"><header><img class="page-cover-image" src="https://images.unsplash.com/photo-1584169417032-d34e8d805e8b?ixlib=rb-1.2.1&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;ixid=eyJhcHBfaWQiOjYzOTIxfQ" style="object-position:center 50%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">🖥️</span></div><h1 class="page-title">Resumo S.O</h1><table class="properties"><tbody><tr class="property-row property-row-select"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesSelect"><path d="M7,13 C10.31348,13 13,10.31371 13,7 C13,3.68629 10.31348,1 7,1 C3.68652,1 1,3.68629 1,7 C1,10.31371 3.68652,13 7,13 Z M3.75098,5.32278 C3.64893,5.19142 3.74268,5 3.90869,5 L10.09131,5 C10.25732,5 10.35107,5.19142 10.24902,5.32278 L7.15771,9.29703 C7.07764,9.39998 6.92236,9.39998 6.84229,9.29703 L3.75098,5.32278 Z"></path></svg></span>Class</th><td><span class="selected-value select-value-color-red">S.O.</span></td></tr><tr class="property-row property-row-created_time"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesCreatedAt"><path d="M6.98643729,14.0000972 C5.19579566,14.0000972 3.40419152,13.3106896 2.04245843,11.9323606 C-0.681017475,9.21200555 -0.680780251,4.76029539 2.04293482,2.04012507 C4.76664406,-0.68004331 9.22427509,-0.68004331 11.9480135,2.04013479 C13.272481,3.36277455 14,5.1330091 14,6.99552762 C14,8.87640182 13.2721894,10.6285043 11.9480135,11.9509302 C10.5679344,13.3105924 8.77756503,14.0000972 6.98643729,14.0000972 Z M10.2705296,7.00913883 L10.2705296,8.46099754 L10.2705296,8.65543362 L10.076181,8.65543362 L8.6543739,8.65543362 L5.72059514,8.65543362 L5.52619796,8.65543362 L5.52619796,8.46099754 L5.52619796,5.52541044 L5.52619796,3.37946773 L5.52619796,3.18502193 L5.72059514,3.18502193 L7.17253164,3.18502193 L7.36692883,3.18502193 L7.36692883,3.37946773 L7.36692883,6.81467358 L10.076181,6.81467358 L10.2705296,6.81467358 L10.2705296,7.00913883 Z M12.1601539,6.99552762 C12.1601539,5.61697497 11.6190112,4.32597154 10.6393933,3.34769528 C8.63253764,1.34336744 5.35197452,1.34061603 3.34153136,3.33944106 C3.33868273,3.34219247 3.33607716,3.34494388 3.33322852,3.34769528 C1.32397148,5.35459953 1.32372842,8.63641682 3.33322852,10.6433794 C5.34295224,12.6504489 8.62968901,12.6504489 10.6393933,10.6433794 C11.6190112,9.66506426 12.1601539,8.37408027 12.1601539,6.99552762 Z"></path></svg></span>Created</th><td><time>@Aug 30, 2020 8:00 PM</time></td></tr><tr class="property-row property-row-url"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesUrl"><path d="M3.73333,3.86667 L7.46667,3.86667 C8.49613,3.86667 9.33333,4.70387 9.33333,5.73333 C9.33333,6.7628 8.49613,7.6 7.46667,7.6 L6.53333,7.6 C6.01813,7.6 5.6,8.0186 5.6,8.53333 C5.6,9.04807 6.01813,9.46667 6.53333,9.46667 L7.46667,9.46667 C9.5284,9.46667 11.2,7.79507 11.2,5.73333 C11.2,3.6716 9.5284,2 7.46667,2 L3.73333,2 C1.6716,2 0,3.6716 0,5.73333 C0,7.124 0.762067,8.33453 1.88953,8.97713 C1.87553,8.83107 1.86667,8.6836 1.86667,8.53333 C1.86667,7.92013 1.98753,7.33447 2.2036,6.7978 C1.99267,6.4954 1.86667,6.12953 1.86667,5.73333 C1.86667,4.70387 2.70387,3.86667 3.73333,3.86667 Z M12.1095,5.28907 C12.1231,5.4356 12.1333,5.58307 12.1333,5.73333 C12.1333,6.34607 12.0101,6.9294 11.7931,7.46513 C12.0059,7.768 12.1333,8.13573 12.1333,8.53333 C12.1333,9.5628 11.2961,10.4 10.2667,10.4 L6.53333,10.4 C5.50387,10.4 4.66667,9.5628 4.66667,8.53333 C4.66667,7.50387 5.50387,6.66667 6.53333,6.66667 L7.46667,6.66667 C7.98187,6.66667 8.4,6.24807 8.4,5.73333 C8.4,5.2186 7.98187,4.8 7.46667,4.8 L6.53333,4.8 C4.4716,4.8 2.8,6.4716 2.8,8.53333 C2.8,10.59507 4.4716,12.2667 6.53333,12.2667 L10.2667,12.2667 C12.3284,12.2667 14,10.59507 14,8.53333 C14,7.14267 13.2375,5.93167 12.1095,5.28907 Z"></path></svg></span>Links úteis</th><td></td></tr><tr class="property-row property-row-file"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesFile"><path d="M5.94578,14 C4.62416,14 3.38248,13.4963 2.44892,12.585 C1.514641,11.6736 1,10.4639 1,9.17405 C1.00086108,7.88562 1.514641,6.67434 2.44892,5.76378 L7.45612,0.985988 C8.80142,-0.327216 11.1777,-0.332396 12.5354,0.992848 C13.9369,2.36163 13.9369,4.58722 12.5354,5.95418 L8.03046,10.2414 C7.16278,11.0877 5.73682,11.0894 4.86024,10.2345 C3.98394,9.37789 3.98394,7.98769 4.86024,7.1327 L6.60422,5.4317 L7.87576,6.67196 L6.13177,8.37297 C6.01668,8.48539 6.00003,8.61545 6.00003,8.68335 C6.00003,8.75083 6.01668,8.88103 6.13177,8.99429 C6.36197,9.21689 6.53749,9.21689 6.76768,8.99429 L11.2707,4.70622 C11.9645,4.03016 11.9645,2.91757 11.2638,2.23311 C10.5843,1.57007 9.40045,1.57007 8.72077,2.23311 L3.71342,7.0109 C3.12602,7.58406 2.79837,8.35435 2.79837,9.17405 C2.79837,9.99459 3.12602,10.7654 3.72045,11.3446 C4.90947,12.5062 6.98195,12.5062 8.17096,11.3446 L10.41911,9.15165 L11.6906,10.3919 L9.4425,12.585 C8.50808,13.4963 7.2664,14 5.94578,14 Z"></path></svg></span>Materiais</th><td><span style="margin-right:6px"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Roteiro_Sistemas_Operacionais_(1).pdf">Roteiro Sistemas Operacionais (1).pdf</a></span></td></tr><tr class="property-row property-row-checkbox"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesCheckbox"><path d="M0,3 C0,1.34314 1.34326,0 3,0 L11,0 C12.6567,0 14,1.34314 14,3 L14,11 C14,12.6569 12.6567,14 11,14 L3,14 C1.34326,14 0,12.6569 0,11 L0,3 Z M3,1.5 C2.17139,1.5 1.5,2.17157 1.5,3 L1.5,11 C1.5,11.8284 2.17139,12.5 3,12.5 L11,12.5 C11.8286,12.5 12.5,11.8284 12.5,11 L12.5,3 C12.5,2.17157 11.8286,1.5 11,1.5 L3,1.5 Z M2.83252,6.8161 L3.39893,6.27399 L3.57617,6.10425 L3.92334,5.77216 L4.26904,6.10559 L4.44531,6.27582 L5.58398,7.37402 L9.28271,3.81073 L9.45996,3.64008 L9.80664,3.3056 L10.1538,3.63989 L10.3311,3.81067 L10.8936,4.35303 L11.0708,4.52399 L11.4434,4.88379 L11.0708,5.24353 L10.8936,5.41437 L6.1084,10.0291 L5.93115,10.2 L5.58398,10.5344 L5.23682,10.2 L5.05957,10.0292 L2.83057,7.87946 L2.65283,7.70801 L2.27832,7.34674 L2.6543,6.98694 L2.83252,6.8161 Z"></path></svg></span>Reviewed</th><td><div class="checkbox checkbox-on"></div></td></tr></tbody></table></header><div class="page-body"><figure id="79925d0f-e6b5-40ec-b76a-b51aa48f28ec"><div class="block-color-blue_background source"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/SO_Semana1.pdf">https://s3-us-west-2.amazonaws.com/secure.notion-static.com/94bd45bc-57e8-4af4-aabd-5e7ad1836028/SO_Semana1.pdf</a></div></figure><h2 id="d2d94a2d-d82a-406b-8dbe-40011df155fa" class="block-color-yellow_background">4) Processes</h2><h3 id="c03ac21b-f928-4a85-98ff-a90c8c2e969b" class=""><mark class="highlight-orange">1. O que é um processo?</mark></h3><div id="82ab81fb-7a7d-4acb-b75f-476e9024089b" class="column-list"><div id="c5230ec1-6f77-4edd-9e7d-0b996ad5bc7c" style="width:50%" class="column"><p id="9e45c69a-0fe3-40af-b444-379a1ceff54e" class=""> 1.  Um processo pode ser considerado similar a um programa em funcionamento. Já que, quando o processo não está em execução ele é apenas uma série de bytes parados no disco rígido.</p><p id="9a0ae797-67ea-4221-bcb6-2eb01254bf24" class="">
</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="cdf19e1f-0600-4cf6-9d87-b35e83e4ab00"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Basicamente um processo pode ser definido como um programa em execução . Quando não está em execução um programa é apenas um apanhado de bytes descansando no Disco rígido. Quando são executado ( através de um process API create ) eles se tornam um processo. Uma CPU pode estar executando milhares de processos ao &quot;mesmo tempo&quot; através da virtualização da CPU e time sharing.</div></figure><p id="a1162013-164c-4c52-acfa-2791f12b6313" class="">
</p><h3 id="f251292b-163c-4230-941d-77b08775eebb" class=""><mark class="highlight-orange">2. Quais os estados de um processo?</mark></h3></div><div id="febbff11-3ce7-48b0-a86d-24c6f4fc32e1" style="width:50%" class="column"><figure id="09fc13ae-34c6-4c3e-91e2-ee1b438ae0fd" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled.png"><img style="width:714px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled.png"/></a></figure></div></div><div id="052f1405-b8f8-49d4-a939-83ca2c7bf417" class="column-list"><div id="11976d95-d391-464f-951f-ee8accf23690" style="width:50%" class="column"><p id="4faeb7e2-f316-4846-841e-c792692f41cc" class="">2. </p><ul id="ea595877-6d1a-45e4-adca-f369e5f4edef" class="bulleted-list"><li><mark class="highlight-teal">Running </mark>(Executando)</li></ul><ul id="f2b6c595-6fa0-41a0-8fb1-6bfceadf62f1" class="bulleted-list"><li><mark class="highlight-yellow">Ready </mark>(Pronto para rodar, mas o S.O escolheu não rodar) </li></ul><ul id="39218f4a-ff17-475d-ae18-ed3685fab7ef" class="bulleted-list"><li><mark class="highlight-red">Blocked </mark>(Não está pronto para rodar)</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="ec289d1a-0502-4590-8ddb-8fc5a1732e7c"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Basicamente os estados de um processo são Running, Ready e Blocked . É necessário também citar que além desses três estados básicos processos também podem ter um estado inicial e um estado final.</div></figure><p id="fcf07ec2-162d-40ca-98e2-9ef6c23fdebb" class="">
</p><p id="df694d50-41a3-491e-b381-0eee8d6fa355" class="">
</p><h3 id="1c92175c-ab89-4a39-8072-8002dedc2427" class=""><mark class="highlight-orange">3. É possível determinar em que ordem os processos executam em um SO? Essa ordem pode mudar de execução em execução, mesmo se os mesmos processos estejam executando todas as vezes?</mark></h3><p id="f7075f98-950a-4742-98b9-9b0f568c3dfa" class="">
</p></div><div id="5083ff61-c220-432d-bf89-a53909a58f15" style="width:50%" class="column"><figure id="0cb888f8-304d-4f80-a8d7-074a2df2a47e" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%201.png"><img style="width:692px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%201.png"/></a></figure><figure id="816d2821-44e1-4d88-b4fa-a9514f6a899a" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%202.png"><img style="width:645px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%202.png"/></a></figure><p id="ad9c2e8f-8ab2-49ea-b744-decbf0f2dfe0" class="">
</p></div></div><div id="c4ef5a50-ec60-48a0-acfb-6dae2260da97" class="column-list"><div id="4528cbc9-5e68-4b4e-b9e6-afdbf0bb1af1" style="width:50%" class="column"><p id="ff5ea528-1d9d-46ab-a0c7-2359346512f6" class="">3.  De forma geral, não podemos fazer grandes premissas sobre qual processo irá executar primeiro, fenômeno que chamamos de <strong>não-determinismo</strong>. Sim, a ordem pode mudar, baseadas, por exemplo, num contexto geral dos outros processos, como mudanças de prioridade ou estado e etc.</p><p id="889318ba-4fe8-412b-97fb-04dc660b884c" class="">
</p></div><div id="0e31f6f3-79be-404f-996d-d6577ec7f87d" style="width:50%" class="column"><figure id="e0ce1224-7c64-42d2-a8bb-002c1de70139" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%203.png"><img style="width:752px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%203.png"/></a></figure><figure id="165a8ca5-04b2-4fe0-a308-569f5560637b" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%204.png"><img style="width:712px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%204.png"/></a></figure></div></div><p id="49ec31cf-e40d-4afc-9069-f699ae4b8e14" class="">
</p><p id="9ad6bb65-5c1c-41a9-b8a9-37b59d70cd12" class="">
</p><p id="56b807b0-c4ec-48cb-b60f-4ac89f4cf276" class="">
</p><h3 id="f496df48-3c23-41bd-a58d-01c935b315aa" class=""><mark class="highlight-orange">4. Quais os dados devemos armazenar para poder gerenciar processos? Determine um exemplo de estrutura com esses dados</mark></h3><p id="5ccb98dd-d177-4462-92b9-d97bf9db1c48" class="">
</p><div id="4b5e5773-7be4-4585-9a79-1db722ca6752" class="column-list"><div id="7bc9f6d0-242e-4dff-9e60-b1cb7f1138c0" style="width:50%" class="column"><p id="0a2b6ddd-3834-45db-99fc-e9044175561d" class="">4.  <strong>Lista de processos </strong>para processos em cada estado (ready, running e blocked) e informações adicionais (<strong>PCB</strong>) para os processos. Dados que são armazenados de forma geral: PID, Endereço de memória, Tamanho da memória do processo, entre outros.</p><p id="f864d59b-c8d2-4554-9a7c-ad6f7d7ae767" class="">
</p></div><div id="59b94241-f915-4d46-98fb-7cccb14104fb" style="width:50%" class="column"><figure id="1de535aa-3380-4338-930e-94c5ca6cbac1" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%205.png"><img style="width:660px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%205.png"/></a></figure></div></div><p id="92d115e4-d3d8-4d17-a71a-b4a69c2c7fed" class="">
</p><p id="cc86293a-c20f-4dbd-9d8e-5fcc51888ad5" class="">
</p><h2 id="7169544f-a7e8-4eda-a46f-6c3f30c78adb" class="block-color-yellow_background">5) Process API</h2><p id="c328dbda-c61b-412c-a7af-df90d8e4daa8" class="">
</p><h3 id="16956044-81e3-4d22-a612-f9e9c6d1cf39" class=""><mark class="highlight-orange">1. Quais as três chamadas principais da API de um sistema UNIX são utilizadas para gestão de processos? Como cada uma delas funciona?</mark></h3><p id="a5e7911a-b514-487e-aa39-ee8ecb2c18b3" class="">
</p><div id="e1024763-712c-409c-841b-d22234b7ebb2" class="column-list"><div id="5fa5890a-358c-4374-91fb-2a1ae7a97d48" style="width:50%" class="column"><ul id="ed10a9f4-8a5e-4187-b2ee-46bccce709ea" class="bulleted-list"><li><strong>fork()</strong> - cria um processo filho a partir de um processo pai</li></ul><p id="368ecc31-ac63-4220-b7c5-47f10830f511" class="">
</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="dd09a35b-0711-49b8-a86b-5d0325a029ab"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">As três principais chamadas de um sistema UNIX são Fork (), utilizado para
basicamente criar um clone de um processo em execução, com as mesmas informações de contexto, com a única diferença sendo o retorno da função fork(), sendo o PID do filho no pai e 0 no filho</div></figure></div><div id="4ba63373-d704-49ec-ad20-07136c0baade" style="width:50%" class="column"><figure id="6b467943-8c36-4bb5-9d09-48907263ffdf" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%206.png"><img style="width:793px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%206.png"/></a></figure></div></div><div id="a2b2ad42-e48a-411e-bb67-97f3504ebf83" class="column-list"><div id="8658711c-29d1-4821-9b95-95d9e0cf3235" style="width:50%" class="column"><ul id="ed9af9e5-fce1-4151-9d22-09dcfab04827" class="bulleted-list"><li><strong>wait()</strong> - espera até outro processo terminar</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="712aa46e-99fc-40c8-8170-0be5cbe4e337"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Wait (), utilizado para esperar que certa execução se encerre,
basicamente ele faz o que seu nome indica</div></figure></div><div id="c1d8497b-c7ef-42d3-b174-b37989558ab2" style="width:50%" class="column"><figure id="ca59bc2a-dfea-4bb7-ac4e-f5cd03ad8309" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%207.png"><img style="width:848px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%207.png"/></a></figure></div></div><div id="868577a6-72a3-40df-890e-434aaa99869f" class="column-list"><div id="d148bf67-f2a0-4e65-ba95-55029d1513c6" style="width:50%" class="column"><ul id="e00da6ba-0e24-451b-8483-c4cc94fb8b6b" class="bulleted-list"><li><strong>exec()</strong> - inicia um novo programa dentro de um processo</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="73ae5e66-c155-4fd0-875f-7ae3b89fd695"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Exec(), utilizado para substituir o processo atual totalmente pelo processo desejado, como não há resquícios do processo que chamou exec(), caso ele tenha sucesso, essa função nunca retorna.</div></figure></div><div id="bba1338c-bd99-4590-9977-c3a5670722fd" style="width:50%" class="column"><figure id="26ac67ab-7c80-434b-9296-95c97c508b99" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%208.png"><img style="width:870px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%208.png"/></a></figure></div></div><p id="c2761f88-e120-474e-90e9-35e5fc1514e0" class="">
</p><h3 id="1f8bcd2b-f323-4d31-b143-b62bc780dfa3" class="block-color-orange">2. Como funciona o fluxo de um programa que crie um processo? Como diferenciar se estamos no processo pai ou no processo filho? Como se dá o fluxo de cada um deles? Dica: a questão de fluxo tem relação com o estudado no capítulo anterior.</h3><p id="32ed187a-d09d-4acc-81df-12fe883670d0" class="">
</p><p id="c87d8358-9990-41b5-bfe6-acef85ecf34a" class=""><strong>Load </strong>→ <strong>Alocação </strong>de Memória → <strong>Iniciar </strong>a main →  fork()</p><p id="3d8352cc-d9a2-402d-a2bd-24689ec2c8f8" class="">Pode-se identificar usando o <strong>PID </strong>(Process Identifier)</p><p id="7c03245c-5c00-4f50-a7e2-5a33d7ab860c" class=""><strong>fork</strong>() → <strong>Alocação </strong>→ <strong>exec</strong>()</p><p id="35351530-f6b8-421d-9b8f-718a339bda1b" class="">
</p><h2 id="60831b5e-f12d-4bef-997f-03f8441d6fb0" class="block-color-yellow_background">6) Direct Execution</h2><p id="8f03327c-a8b6-4815-8cae-8013972b1ccd" class="">
</p><h3 id="e9872adf-02c1-4ae0-ac87-44184835e8c3" class=""><mark class="highlight-orange">1. Em que consiste o Limited Direct execution Protocol? Quais as questões que em que ele atua?</mark></h3><div id="a525a903-6498-4313-ada7-621b72bd209b" class="column-list"><div id="dddbeb2a-6f4e-48d2-9552-e51a1d79b142" style="width:50%" class="column"><p id="99e9d47f-8a2e-460a-aaeb-13d261876bd2" class="">1.   O limited Direct Protocol é um mecanismo criado para resolver a questão de time sharing inerente a virtualização da CPU. Basicamente ele atua proporcionando a execução <strong>direta </strong>do programa na CPU. Para evitar falhas de segurança, o Limited
Direct Execution protocol introduz o <strong>User mode</strong>, modo em que os códigos são
executados com diversas restrições sobre o que se pode fazer e caso o programa
necessite de alguma operação privilegiada ele pode efetuar uma system call , que
permite que o SO libere certas partes de dados ou funcionalidades exclusivas do modo kernel . Dessa forma, conclui-se também que o protocolo é adotado para fazer com que a virtualização da CPU ocorra da maneira mais eficiente possível em questão de velocidade, segurança e estabilidade.</p><p id="587be112-7fa5-4e10-b0cc-87812f454e4b" class="">
</p><p id="dc75bf26-3d86-4390-b593-608898f67670" class="">
</p><p id="d413ba5f-f81b-49c9-a5ff-613b04d5330b" class="">
</p><h3 id="d6167620-42d4-4eeb-ac08-c92fca9cf2a0" class=""><mark class="highlight-orange">2. Quais as maneiras de se mudar o contexto, ou seja, o processo que está em execução?</mark></h3></div><div id="a285b8d4-6eee-4bad-8198-30010affb126" style="width:50%" class="column"><figure id="65f3f298-03f8-4eb4-b066-85d87f010cdb" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%209.png"><img style="width:681px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%209.png"/></a><figcaption>Fluxo das instruções</figcaption></figure><p id="7124fddf-c742-4bc6-8417-e070c1b0950e" class="">
</p></div></div><p id="8d8d1fae-a3b4-4142-a08f-d13598284564" class="">2. Existem três formas de se mudar o contexto (processo em execução), elas são:</p><div id="1e94621c-784c-4db9-97c7-c5424b29944b" class="column-list"><div id="226a83ab-bb4f-4e0a-95a7-f8d83511d7a8" style="width:50%" class="column"><ul id="e1218879-07f2-4fa4-a3c8-def6e865c236" class="bulleted-list"><li>Forma <strong>cooperativa </strong>→ System Call</li></ul><p id="cea2be7b-176c-43b8-9386-52725a85a074" class="">→ Um processo amigável transfere controle para a CPU fazendo system calls para, por exemplo, abrir um arquivo e lê-lo ou criar um novo processo. Sistemas como esse geralmente incluem uma chamada de sistema yeld(), que serve somente para transferir o controle de volta ao sistema operacional para que ele possa rodar outro processo.</p><p id="1ca988db-316f-4513-a449-3b6a10f974fe" class="">
</p></div><div id="e32b35df-5d89-434d-b54d-37de4893aa2a" style="width:50%" class="column"><figure id="ec85935a-4df2-4198-ba10-26727a6b4582" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2010.png"><img style="width:837px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2010.png"/></a></figure></div></div><div id="bf6aa293-ed1b-47e6-b469-88b761989e23" class="column-list"><div id="5adab0ac-442a-46f9-b94f-c08b3b8a7a63" style="width:50%" class="column"><ul id="fa6de651-e04b-4cf2-9d36-9211b2c43118" class="bulleted-list"><li>Forma <strong>não-cooperativa </strong>→ Timer Interrupt</li></ul><p id="f9c0c282-62dc-4145-8e61-709a7919b425" class="">→ Em caso de um processo que não esteja se comportando da forma adequada, o timer interrupt é acionado. Um sistema de timer é configurado para emitir uma interrupção após alguns milisegundos; quando a interrupção é emitida, o processo é parado e um interrupt handler pré-configurado no S.O entra em ação.</p><p id="3aada821-b461-431e-bc51-a6bbac70132d" class="">
</p></div><div id="c1b113e5-0f2f-4a56-9f2b-56dab324c2ae" style="width:50%" class="column"><figure id="a8ef85e1-4065-4bac-9223-1e3059a38f24" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2011.png"><img style="width:821px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2011.png"/></a></figure></div></div><ul id="cb397e8a-0e1a-4b04-ad8a-b32e6e52d922" class="bulleted-list"><li>E a conclusão do processo</li></ul><p id="b5948174-0ada-4339-854e-55b6b255f0e5" class="">
</p><h3 id="38c334f1-187b-4532-a880-610e22efc396" class=""><mark class="highlight-orange">3. Como salvar e restaurar o contexto? Quais dados são importantes?</mark></h3><div id="6d35f0ff-d836-4662-b1b6-dfaf8a00e8a0" class="column-list"><div id="169b7a22-4277-46b4-80d1-3fe619bb8d7d" style="width:50%" class="column"><p id="2ede6ab5-41a7-4bf4-8e7f-55999a3d077b" class="">3.  Para ocorrer um context switch, o estado que o processo se encontra precisa ser salvo. Dessa forma, o S.O executa um código low-level em assembly para salvar os todos os registradores que o programa pode estar usando, principalmente o <strong>program counter, </strong>além de salvar outros dados como o Kernel Stack Pointer que são necessários para a execução. Esses dados geralmente são salvos numa estrutura de dados chamada <strong>process control block (PCB)</strong>. Para restaurar, ocorre a restauração dos valores dos registradores, o switch de fato, alterando o processo antigo pelo novo e quando o SO executa as instruções return-from-trap a restauração está terminada.</p></div><div id="f06f1dd6-ffda-4195-8fe0-e322de8e9761" style="width:50%" class="column"><figure id="adbca77a-3e4c-48d7-b700-93cf30252798" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2012.png"><img style="width:344px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2012.png"/></a></figure><p id="b9e89b32-39b1-40e9-880b-58e527dcf233" class="">
</p></div></div><p id="2e7c52bb-1698-42aa-81f9-0b6d3e831662" class="">
</p><figure id="11d3ffaf-a072-4f47-af6a-391f8212d746"><div class="block-color-blue_background source"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/SO_Semana2.pdf">https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6c3890dd-45f9-487e-912b-2f821eb48b11/SO_Semana2.pdf</a></div></figure><h2 id="9e97e2fb-475d-476c-9211-cd0af783621a" class="block-color-yellow_background">7. CPU Scheduling</h2><p id="049c2a2b-4dec-4672-a567-e4b1be9b1d86" class="">
</p><h3 id="b71b2950-6461-48f7-acad-8fb559d6637f" class=""><mark class="highlight-orange">1. Como funciona o algoritmo FIFO? Quais as vantagens e desvantagens?</mark></h3><div id="95ec00b7-703c-49b2-b8d1-d93b630ec386" class="column-list"><div id="4b63128a-43f2-4a98-aa0a-b880ea5dd2c7" style="width:50%" class="column"><p id="b598a9e5-1238-4c73-b5b1-f738f004f661" class="">1.   O algoritmo <strong>FIFO (First In First Out)</strong> ordena as tarefas em ordem de chegada, suas vantagens são ser um algoritmo simples e fácil de entender e implementar, as desvantagens são que ele é um algoritmo não <strong>preemptivo</strong>, ou seja, não existe prioridade entre os processos, além de ele não ter um tempo médio de espera otimizado, também pode gerar o efeito <strong>convoy</strong>, onde processos relativamente pequenos demoram a ser executados devido a um longo processo.</p><p id="da8c842c-6e08-4894-ae09-a4b8cdba1b55" class="">
</p><p id="3b44ed43-7fea-4010-9e7b-0b15879fdbc3" class="">
</p><p id="4638e0a7-0a47-490c-8e92-cb7b2ef953c0" class="">
</p><p id="7160066b-8616-43e5-a0ec-c7d14ede9ed1" class="">
</p><p id="9c5d7651-bab4-491d-93eb-cc3861a16d62" class="">
</p><p id="b809a550-97c0-4bc5-802d-18d2d987ffda" class="">
</p><p id="9fff4e3c-9c11-451b-9bdb-20da5841e8d4" class="">
</p><p id="bbf6c0e5-a791-491f-a0d3-0a86cc79f524" class="">
</p><p id="2735b837-0ff5-4bed-92a3-30343e7229ca" class="">
</p><p id="73a9a85a-dba8-4df0-9997-4601715cbe27" class="">
</p><h3 id="65e9e4ab-ca80-443f-b370-02f9e28ced23" class=""><mark class="highlight-orange">2. Como funciona o algoritmo SJB? Quais as vantagens e desvantagens?</mark></h3></div><div id="649c3d1b-cf0d-40aa-aeb1-0e6b72c72401" style="width:50%" class="column"><figure id="f4a0b0fd-3a7e-42b7-ba58-f2264e74f2ca" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2013.png"><img style="width:789px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2013.png"/></a></figure><figure id="56faebd3-51cd-476e-a969-631bedec533c" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2014.png"><img style="width:730px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2014.png"/></a></figure></div></div><div id="b746f099-06fa-444a-b48f-0aeea44eb0d7" class="column-list"><div id="a2d6e91e-2147-4046-88a1-0adc97f64a35" style="width:50%" class="column"><p id="7df44ea8-a233-462a-b7cd-84102d01cea5" class="">2.   O algoritmo<strong> SJB (Shortest Job First)</strong> ordena as tarefas com base no tempo de execução. Vantagens: Minimiza o tempo de espera, Problemas: pode gerar <strong>starvation (sequência de processos curtos não deixarem um processo maior executar) e convoy effect (processo grande)</strong></p><p id="a429b984-946f-45d6-9c36-4bd5a4e66340" class="">
</p><p id="b064f216-5eb4-4054-ac5c-40362ec10311" class="">
</p><h3 id="a273d87e-1696-4896-bf95-15c1e17ea7c6" class=""><mark class="highlight-orange">3. Como funciona o algoritmo STCF? Quais as vantagens e desvantagens?</mark></h3></div><div id="7f39c434-9f9c-4aa3-813c-2e6b7fb1da1d" style="width:50%" class="column"><figure id="54477e41-08ff-4216-a997-1bd246028fc7" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2015.png"><img style="width:813px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2015.png"/></a></figure></div></div><div id="2ca61c70-be2b-4c3d-8311-e78cd18fc473" class="column-list"><div id="1840a56c-4c9f-4859-b056-f8ad2c744ce2" style="width:50%" class="column"><p id="4b4e712e-081b-4d5d-ba4f-c3cc75000934" class="">3.   O algoritmo <strong>STCF (Shortest Time-to-Completion First)</strong> ordena as tarefas com base no tempo de conclusão, porém, de forma <strong>preemptiva </strong>(dando prioridade aos processos). Vantagens: É um algoritmo mais rápido que o SJB em alguns casos. Problemas: Mais difícil de ser implementado e o algoritmo pode ter um tempo de resposta muito ineficiente, já que os processos podem demorar muito para serem escalonados pela primeira vez.</p><p id="c05a3c7a-ef80-4d42-b9f5-0aa471cf34b7" class="">
</p><p id="5c902649-6ed8-4143-b6dc-a6d829dd30c5" class="">
</p><p id="bb9d5d9b-4e21-4f0d-8913-01af44422982" class="">
</p><p id="888770be-937d-4dc1-b2ea-c94addf4e3c4" class="">
</p><p id="c4ddb5f1-6326-43b2-a92d-3d4962587838" class="">
</p><p id="f2f0006f-51e2-48f3-a100-baeb6f0d5ce0" class="">
</p><p id="c68909a3-df02-4074-bda0-83f0e1d9286b" class="">
</p><p id="1f730626-a84e-4db7-99e5-230a53c32704" class="">
</p><p id="b0f5cd85-65ee-4305-8262-d441df87139f" class="">
</p><p id="6bb832c9-dca5-4679-a9ae-3b6e1c0c61ff" class="">
</p><h3 id="f8a6e90f-1c1a-4603-8a06-605bb0094cb0" class=""><mark class="highlight-orange">4. Como funciona o algoritmo Round Robin? Quais as vantagens e desvantagens?</mark></h3></div><div id="1d6998fe-e897-4a8e-ba0a-5aeccc39e67e" style="width:50%" class="column"><figure id="d8dcd762-cfbc-4ee6-8226-324f0a349bc0" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2016.png"><img style="width:723px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2016.png"/></a></figure></div></div><div id="8c9122b1-c11e-4390-ab5d-7ac5d5849350" class="column-list"><div id="0805f26c-9ae9-4a9a-aa8f-66d34226637b" style="width:50%" class="column"><p id="04447168-e0f3-4597-8e21-6ef5c59bb517" class="">4.   O algoritmo <strong>Round Robin</strong> ordena as tarefas com base na ordem de chegada e alterna entre elas a cada <strong>quantum </strong>(time-slice) de tempo. Vantagens: Elimina o problema de starvation ou efeito convoy, todas as tarefas pegam uma quantidade justa de alocação no CPU. Problemas: Esse método gasta mais tempo em context switching, a sua performance depende muito do quantum certo e encontrar um quanto certo é difícil.</p><p id="94b4bbb2-f26f-4398-84e2-06d59e1943cf" class="">
</p><p id="d87ce8dd-e0f6-4257-9bfc-68d7fa6faeb5" class="">
</p><h3 id="2ffd61b2-7a22-4c06-a692-1528f1eeeafd" class=""><mark class="highlight-orange">5. O que a ocorrência de operações de I/O introduz no modelo de escalonamento?</mark></h3><p id="813b2e0b-41e1-42a6-840b-2d1deda73560" class="">5.   Quando um processo solicita um I/O seu status fica como bloqueado até a conclusão do I/O , dessa maneira , por questões de otimização , o escalonador tem que tomar duas decisões , uma quando o processo entra em I/O e outra quando o processo retorna do I/O. Nos momentos onde o processo está bloqueado, o S.O faz um overlap e executa outro processo enquanto o I/O ainda não foi executado, salvando assim, recursos e tempo de processamento.</p><p id="65a75e8b-8572-44d7-a266-a29f80adb259" class="">
</p></div><div id="88b18fa9-b9b1-4b19-830a-a9263aab5c44" style="width:50%" class="column"><figure id="245baf54-67ac-4250-8127-5349b5dcd58b" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2017.png"><img style="width:834px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2017.png"/></a></figure><p id="334f00b9-fa17-41b5-ba66-16b87a5cbbe8" class="">
</p><p id="56b41949-d887-426d-9811-e8efab848f75" class="">
</p><p id="adc753a5-fc2d-4eb4-b161-d1775c0003be" class="">
</p><figure id="a25d9993-1524-445e-8d46-8a572196ffc1" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2018.png"><img style="width:767px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2018.png"/></a></figure><p id="4c6ff5e6-5a61-4f09-a55a-e3bc942ed6ab" class="">
</p></div></div><p id="f7c6ffa1-d041-4e09-b371-a6e2e0166487" class="">
</p><h2 id="a122adc4-5315-4d27-9153-afe2b8c5d647" class="block-color-yellow_background">8. Multi-level Feedback</h2><p id="939846f0-981b-4131-9086-66cb6287315e" class="">
</p><h3 id="af8f7999-5356-4c4d-88b0-aa4ba6ce5d9e" class=""><mark class="highlight-orange">1. Como funciona o algoritmo MLFQ?</mark></h3><div id="b07dae7a-3945-4783-b06c-01e0d8c664c7" class="column-list"><div id="227a0ef7-bd47-470b-bbda-f9175062f85d" style="width:50%" class="column"><ol id="cfcc9f32-69e3-4cb7-a998-42afd41807d0" class="numbered-list" start="1"><li>O <strong>algoritmo MLFQ</strong> adiciona <strong>queues </strong>de processos, cada uma podendo ter o seu próprio algoritmo de ordenação de tarefas. Além disso, ela coloca prioridade dentro das queues, fazendo as de maior prioridade serem executadas primeiro. Também são adicionadas funções para os processos poderem se mover dentro das queues, sendo assim, um processo que usa muito tempo de CPU vai ser movido para uma queue de baixa prioridade. É o esquema mais geral e complexo de todos apresentados.</li></ol><p id="aac7dc1e-1d90-4cfe-b55f-74189a8e46dc" class="">
</p></div><div id="67a7dfbb-916a-427f-bba7-0fc11fa52661" style="width:50%" class="column"><figure id="4676cad4-7cdc-49c6-b049-96b100c9fbbf" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2019.png"><img style="width:839px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2019.png"/></a></figure></div></div><p id="ffc7350c-0812-4311-b163-0feb0958491a" class="">
</p><h2 id="f630988b-799c-4a18-9504-67de17ed94dc" class="block-color-yellow_background">9. Lottery Scheduling</h2><p id="229eca6a-d59d-46f0-bba6-4a8c8605153b" class="">
</p><h3 id="9a9d9b4b-1f8e-4004-941f-5a1661d27a49" class=""><mark class="highlight-orange">1. Como funciona o escalonamento por loteria?</mark></h3><div id="b386cfd4-3e3a-4235-bbd1-0e59a97c261b" class="column-list"><div id="c96281d5-dd9f-4f55-b269-32a78830384b" style="width:50%" class="column"><ol id="fa011e6f-7db0-4355-b07b-76479a33aa2d" class="numbered-list" start="1"><li>Baseada no contexto de tickets (uma abstração utilizada para representar a porcentagem de CPU que um processo deve receber). Funciona da seguinte forme: Dê a todas as tarefas um número de <strong>bilhetes (tickets) </strong>e escolha um número <strong>aleatório</strong>, o vencedor com (geralmente o que tem maior número de bilhetes) entra em execução. Ela alcança a justiça em termos de tempo de CPU disponível por processo probabilisticamente, após várias execuções da loteria.</li></ol><p id="ea6fae5c-dab8-4a2f-8794-6afe1a9c1acf" class="">
</p><p id="9bee1421-3978-449e-bed6-48ce26f9292b" class="">
</p><p id="5d57ab32-ddf8-4546-b369-9b077533012f" class="">
</p><h3 id="e9a2ca04-e199-4f17-aaac-1060e50601eb" class=""><mark class="highlight-orange">2. Como funciona o escalonador do Linux, o Completely Fair Scheduler (CFS)?</mark></h3></div><div id="c710aa4d-69bb-46d4-96d9-63e2be1a04d0" style="width:50%" class="column"><figure id="f8a92c53-9110-4724-93b7-70b97da4dab2" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2020.png"><img style="width:920px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2020.png"/></a></figure></div></div><div id="090a6d3a-f749-4eef-8216-509e074f1964" class="column-list"><div id="ebb415aa-7bc0-4e2a-bee8-abfdbf5cbe05" style="width:50%" class="column"><p id="93e78248-8150-4b2c-b481-aa5054607bf5" class="">2.   Ele é uma estrutura de árvore que se auto ajusta, ordenada pelo <strong>virtual run time</strong>. Conforme os processos são executados, eles acumulam vruntime e quando um novo escalonamento for necessário, o CFS pegará o processo com o menor vruntime para rodar em sequência. É importante ressaltar que o CFS adota um sistema de Niceness para indicar as prioridades dos processos, alterando o vruntime para dar a prioridade específica. Além disso, o CFS organiza os processos sendo executados em uma Red-Black-Tree, uma estrutura para ordenar os processos baseados no seu vruntime.</p><p id="dc14c2b8-3779-46be-b0e0-ffe8105d5045" class="">
</p></div><div id="b8b7bb10-dae2-4bf7-9c80-1eb05c9239fc" style="width:50%" class="column"><figure id="638aa4c1-713f-41af-9c05-80a586b37031" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2021.png"><img style="width:786px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2021.png"/></a></figure><p id="c583ebec-a0ec-49a1-b36c-5a6e77421854" class="">
</p></div></div><h2 id="2bbe8438-bae1-4f40-8750-369c05f32d33" class="block-color-yellow_background">10. Multi-CPU Scheduling</h2><p id="d91a8b78-f3ae-49ef-9872-4ba56cd30cbe" class="">
</p><h3 id="f4e5d125-587d-4705-9a41-49326aa6c137" class=""><mark class="highlight-orange">1. O que são os conecitos de localidade temporar e espacial?</mark></h3><p id="da786264-0c1d-43df-add4-352d094d355a" class="">
</p><div id="1008adf1-9b4a-460c-8f44-fbb2959b4364" class="column-list"><div id="2fdf2780-7352-4a8e-8615-0ba389f6a1ba" style="width:50%" class="column"><p id="62d5b8e3-69f1-4f5a-a074-f4c4299c21a8" class="">1.   São conceitos que baseiam o funcionamento dos caches. A ideia por trás da <strong>localidade temporal </strong>é que ao acessar uma informação, é provável que ela seja acessada novamente num futuro próximo e a ideia por trás da <strong>localidade espacial </strong>é que se um programa acessou dados em um endereço X, é provável que acesse outros itens próximos a X também. A partir desses conceitos, os sistemas de
hardware podem fazer um estimativa bem precisa dos dados à armazenar na memória cache.</p><p id="126392aa-a2c4-42b7-9e5a-eedf24b85044" class="">
</p><p id="f347472f-f89f-483c-8d6f-31180701ea44" class="">
</p><h3 id="4494f8eb-ee0b-4c09-bf5e-7f84bf21b363" class=""><mark class="highlight-orange">2. Qual o problema introduzido na questão de escalonamento em multiprocessadores quando pensamos em sincronização?</mark></h3></div><div id="00cca2a0-022e-483f-8c37-7ee8e13fc785" style="width:50%" class="column"><figure id="0c089cf5-4b4d-42a4-a10c-3df3c0abae80" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2022.png"><img style="width:799px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2022.png"/></a></figure></div></div><div id="c2d489a4-3237-4fba-9e44-30d174aea801" class="column-list"><div id="76002a56-222b-4550-b839-712b997b8a2c" style="width:50%" class="column"><p id="fed525b4-204e-4815-b22a-9a38de55fa2d" class="">2.   Com relação a sincronização , um dos principais problemas que enfrentamos é relacionado ao fato de múltiplos CPUs estarem acessando ( e alterando ) dados compartilhados e estruturas compartilhadas. Dessa forma, é necessária a implementação de um mecanismo de limitação de acesso a esses recursos ,como
LOCKS para garantir que as informações acessadas estão corretas. Adicionar essas travas resolve o problema da sincronização, entretanto, cria um problema de escalabilidade.</p><p id="f1a26506-0631-4491-aa17-43f7067ccaa5" class="">
</p><h3 id="9082a2f6-1f25-466c-8c34-e690fc963058" class=""><mark class="highlight-orange">3. Como funciona o Single Queue Multiprocessor Scherduler (SQMS)? Quais os problemas apresentados por esse algoritmo?</mark></h3><p id="3c1a2fd9-c17a-4c44-b9b1-38cc58c33301" class="">
</p></div><div id="ed86c3d3-767e-4591-b88d-798ba2768b2b" style="width:50%" class="column"><figure id="9cac443e-e864-4951-b2d8-831405680e98" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2023.png"><img style="width:846px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2023.png"/></a></figure></div></div><div id="84a789d1-c1da-4c93-9d3d-030d6d5b63f9" class="column-list"><div id="e735f822-bde0-4910-a3f3-2f05a40d795f" style="width:50%" class="column"><p id="86409219-a066-4113-956d-49d12fa6ddb6" class="">3.   Ele vai funcionar reaproveitando os escalonadores de um único processador, alocando todos os processos em uma única fila e repassando para cada CPU. Problemas: Falta de escalabilidade e problemas com cache <strong>affinity</strong>. O primeiro problema é que para garantir seu funcionamento, é necessário adicionar alguma forma de <strong>locking</strong> no código, contudo, a adição de locks reduz a performance do sistema, ainda mais quando o número de CPUs sobe. Já o segundo problema seria que é mais eficiente para um processo que seja executado em um processador que tem suas informações armazenadas já em sua memória cache, dessa maneira é necessário que o SQMS implemente um mecanismo de cache affinity , para
executar, se possível, no mesmo CPU que estava anteriormente. O algoritmo é simples de implementar, mas claramente não se mostra escalável e não preserva a afinidade de cache de maneira exemplar.</p><p id="ff11ed54-f02a-4446-85ca-a9c04df352f7" class="">
</p><h3 id="afd552e2-e5b9-4a31-9b88-d4454934e0a0" class=""><mark class="highlight-orange">4. Como funciona o Multi Queue Multiprocessor Scherduler (MQMS)? Quais os problemas apresentados por esse algoritmo?</mark></h3></div><div id="c3d2a0a1-98a7-4208-8e36-39d06367fff9" style="width:50%" class="column"><figure id="80cf253d-5c18-4f16-bf65-41b9d2001f0b" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2024.png"><img style="width:920px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2024.png"/></a></figure></div></div><div id="03ba7e72-ffa7-4abc-8fa1-09b924c73008" class="column-list"><div id="909e2f15-e4b0-4c89-ae06-7eae7807966a" style="width:50%" class="column"><p id="478943e7-8c3e-4d09-bd68-ca144b1f097b" class="">4.   Ao contrário do SQMS, o MQMS não possui apenas uma fila global, mas cada processador tem uma fila própria de processos. Cada queue vai seguir uma disciplina de schedule particular. Quando uma tarefa entra, ela é escalonada em uma queue independentemente, evitando alguns problemas do SQMS já que ele proporciona uma afinidade de cache inata. Entretanto, ele acaba por apresentar um novo problema: o <strong>load imbalance</strong>, que consiste em basicamente uma distribuição incorreta de tempo da CPU, quando, por exemplo, uma CPU está se dedicando a um processo apenas, e outras CPU está executando múltiplos processos. Para resolver esse problema, temos que fazer o que é chamado de <strong>Migration</strong>, migrando assim que necessário, um processo de uma CPU para outra, atingindo dessa forma, o equilíbrio.</p></div><div id="bfb42255-097e-477a-bec8-71576910271a" style="width:50%" class="column"><figure id="c975da33-18e0-42a3-b44e-e5b7f225cb0f" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2025.png"><img style="width:875px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2025.png"/></a></figure></div></div><p id="e4701548-bf48-4da5-9da0-8b2f5a338c60" class="">
</p><p id="2d8933c0-11b7-461f-b1b4-9fe4df425fd3" class="">
</p><p id="691a5c68-555b-462d-8363-2074250862e8" class="">
</p><figure id="43c084f7-2d09-4409-8818-a38ab4d35710"><div class="block-color-blue_background source"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/SO_Semana3.pdf">https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2595f621-3393-4620-a57e-d70a96229130/SO_Semana3.pdf</a></div></figure><h2 id="9b53a933-86bc-40f5-9361-04f162254382" class="block-color-yellow_background">13) Address Spaces</h2><p id="3bc76eb3-5e33-4aae-a7d1-dab87987ad47" class="">
</p><h3 id="e94e912a-8bbe-4635-90a7-b861655ff877" class=""><mark class="highlight-orange">1. O que é espaço de endereçamento?</mark></h3><div id="261ea029-e658-4223-afcc-f72eb1fc9042" class="column-list"><div id="d110e007-3277-417a-b176-0ff530f3461c" style="width:50%" class="column"><p id="411294e5-eeba-446c-9f7a-be96e8b10703" class="">   1.   Espaço de endereçamento é uma <strong>abstração </strong>da memória física, basicamente a visão que o programa tem da memória disponível para seu uso do sistema. O código do programa, a stack e a heap estão dispostos dentro desse espaço de endereçamento. É importante ressaltar que tal espaço é a abstração que o sistema operacional está fornecendo para o programa em execução, já que o programa não pode ter acesso livre e direto a memória física.</p><p id="2fd8a2ec-17ac-4aa6-a6f7-fa8b83223995" class="">
</p><p id="49423eb2-7071-47de-b6e6-f6ba972b8bed" class="">
</p><p id="ab1670c3-4f7f-4ee8-95b0-3e117f464ed1" class="">
</p><p id="dc1cc49b-511b-4cd7-b2ba-7d7bea1ebbbc" class="">
</p><p id="8526f5a7-dbc1-4286-9c63-3524a73849f8" class="">
</p><h3 id="96f29d67-8f8b-41e1-b263-33267a265550" class=""><mark class="highlight-orange">2. Em um modelo simples que não contempla multiprogramação, qual a direção de crescimento da heap? E da stack? Qual a razão dessas direções?</mark></h3></div><div id="a7c3ec09-e09f-47bd-abf2-e7a80ff5162f" style="width:50%" class="column"><figure id="e92c324f-bcbf-45d1-919a-bf4b705dea1c" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2026.png"><img style="width:672px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2026.png"/></a></figure></div></div><div id="21a315ef-ec82-4ec6-b1dd-591630904d41" class="column-list"><div id="9d8b9094-80a2-4eb9-93da-7dbdc4c2a057" style="width:50%" class="column"><p id="b5d590ce-635a-42c5-ac8f-0e4cd739d5b1" class="">  2.   A direção do crescimento do <em>heap </em>é para baixo, já a direção de crescimento da <em>stack </em>é para cima, eles precisam crescer em direções opostas para garantir o maior aproveitamento e funcionamento da memória e a ordem <em>heap-stack </em>foi adotada por convenção.</p><p id="2f497697-94e5-4802-944f-741daf720ebc" class="">
</p><p id="062a9bc3-5ebf-4c7f-a181-51e1cce2c114" class="">
</p><p id="d73ee161-352f-4514-b49b-02dd53e1b304" class="">
</p><p id="ca3ddec7-5030-4d50-8b0a-c312113a7094" class="">
</p><h3 id="1193b0f4-2731-4ad1-8a49-2fe04e047491" class=""><mark class="highlight-orange">3. Quais as preocupações em termos de transparência, eficiência e proteção devemos ter em mente quando se trata de gestão de memória?</mark></h3><p id="b0b4658d-e737-4b31-85d5-78e0601f3960" class="">
</p></div><div id="6af49b47-d46f-40dc-aa42-756d15ebc90a" style="width:50%" class="column"><figure id="ae55f021-3f4c-4f1f-a8f5-7fa455b7890c" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2027.png"><img style="width:672px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2027.png"/></a></figure></div></div><p id="5a49c486-43a8-415c-9d00-0714ab2ac839" class="">  </p><p id="55a4ee07-efd4-402c-8403-8c9bb300d709" class="">  3.   </p><div id="2c124c44-165e-4c7a-bc36-0dcaf0c96509" class="column-list"><div id="26de10d6-9248-441d-8454-fcc16bcd8763" style="width:50%" class="column"><p id="0b87ea68-50d8-4073-8edd-f417141893dc" class="">Transparência - O S.O deve implementar a memória virtual de uma forma que é <strong>invisível </strong>para o programa. Dessa forma, o programa não deve saber que a memória é <strong>virtualizada </strong>e deve agir como se tivesse a sua própria <strong>memória física privada</strong>. </p><p id="e1ad172a-3f0b-4343-8a2d-78822402e8e9" class="">
</p><p id="42a0bb75-9698-414f-b7c3-fd98b62c80d7" class="">Eficiência - O S.O deve ser o mais eficiente possível, tanto em termos de tempo quando de espaço. Para implementar isso, ele precisará da ajuda do hardware (Ex: TLB). </p></div><div id="669dcc98-10a6-4c77-8ef4-9f4c586f417b" style="width:50%" class="column"><figure id="ab826140-0cc2-42a7-a784-961d61d3cdec" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2028.png"><img style="width:720px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2028.png"/></a></figure><p id="ca6e9ffa-73fe-402e-8c22-b38d28a72cdb" class="">
</p></div></div><div id="f12be0d4-8576-49fb-8fd3-5eadc12505aa" class="column-list"><div id="fbcc18d3-5c26-4b89-90f3-503ed2aded5f" style="width:50%" class="column"><p id="4a16134e-5753-44f0-855d-37c9e78bc235" class="">Proteção - O S.O deve proteger os processos uns dos outros tanto quanto proteger o próprio S.O dos processos. O processo não deve ter acesso aos conteúdos da memória de outros processos ou do S.O, garantindo o <strong>isolamento entre processos</strong>. </p><p id="afee6640-5309-43d7-af92-bc6f09fcb561" class="">
</p></div><div id="9c831eba-e201-4a05-9ad7-8ab013a265be" style="width:50%" class="column"><figure id="4a72c2f1-b7d1-4790-b947-f9cb3246bf6f" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2029.png"><img style="width:712px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2029.png"/></a></figure><figure id="9bb6c2f6-bb0d-4eb4-8582-5064f53575ff" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2030.png"><img style="width:724px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2030.png"/></a></figure><p id="600ea667-5088-4d28-95f0-b7b321505999" class="">
</p></div></div><p id="27225002-7465-4743-8fa4-96c85b4c7f35" class="">
</p><p id="17c7e104-b84b-4919-bbf6-166c742cc313" class="">
</p><h2 id="7f99e4df-b706-48ab-8a08-590adcbdf6d3" class="block-color-yellow_background">14) Memory API</h2><p id="0bbdf3f6-233c-42e2-9d4c-26aff5eeeddc" class="">
</p><h3 id="3c395d54-b444-40fc-bb43-8c6679268c1f" class=""><mark class="highlight-orange">1.Entender as questões envolvidas nas chamadas de malloc(), free(), principalmente o tratamento de retorno, a não alocação de memória antes de utilizá-la, as consequências de não desalocar memória alocada dinamicamente</mark></h3><div id="fd3ab049-6d59-47f3-af0c-19ebea75084c" class="column-list"><div id="82b594e9-514c-4b8f-b11b-c32441e6583e" style="width:50%" class="column"><p id="7202e117-e6c5-4dd0-ac91-98151c95a081" class=""><strong>malloc()</strong> - Ao passar um tamanho ou ele é bem sucedido e te passa um ponteiro para o espaço recém alocado na heap ou falha e retorna NULL</p></div><div id="fc3c3db5-d278-4e54-a943-8f2a01d601cf" style="width:50%" class="column"><figure id="5a124e80-4cd4-4c8b-b098-fa66d353b834" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2031.png"><img style="width:793px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2031.png"/></a></figure></div></div><div id="c6cac886-7fb4-42ce-9ae9-2e564c112bfe" class="column-list"><div id="89e32112-511c-4523-8ab8-84c56fb761cc" style="width:50%" class="column"><p id="bd59a8b5-a5ed-405d-bff2-627bc3a6fa50" class=""><strong>free()</strong> - Ao passar um ponteiro retornado por malloc(), ela libera o espaço em memória referente aquele ponteiro.</p><p id="5da35ce3-00c7-4d1c-9be2-da7cbdd007cb" class="">
</p></div><div id="a7c82fe3-460a-4bd1-9955-c0ef6243ab78" style="width:50%" class="column"><figure id="a4ea61ca-ca39-4370-aa2a-82e569ce20ca" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2032.png"><img style="width:837px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2032.png"/></a></figure></div></div><p id="7a0814d1-c819-42ab-9dd2-9d4d57fe7126" class="block-color-red">Erros comuns -</p><p id="c445d443-27da-49c2-a465-64c650a7b604" class="">
</p><div id="9a797ca9-98dd-4630-8dde-fc91fef74ead" class="column-list"><div id="0bd09b92-ebb4-4eb4-bd79-288485829da5" style="width:50%" class="column"><p id="60ddfbeb-55ea-47da-b806-bb7bbf817f26" class="">→ Não alocar a memória antes de utilizá-la (segmentation fault)</p><p id="bbe5cff6-9065-4692-bf11-95565808bf6a" class="">→ Não alocar o espaço suficiente (buffer overflow → erro imprevisível)</p><p id="bb75aa22-eb7b-483e-aba0-3bbae1bd33ae" class="">→ Esquecer de inicializar a memória alocada (leitura de valor desconhecido)</p><p id="58111e59-db68-4c6e-934d-9cc5457c7899" class="">→ Esquecer de liberar a memória (memory leak)</p></div><div id="e15850bf-d517-4d57-9c55-abf53a919167" style="width:50%" class="column"><figure id="d65ed45d-8234-44fd-ad55-0251d9990b46" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2033.png"><img style="width:745px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2033.png"/></a></figure></div></div><p id="1934f8e2-effd-4d3b-9097-c7585358b0b4" class="">
</p><h2 id="8f84402e-a594-4c6f-a567-63320206fc4c" class="block-color-yellow_background">15) Address Translation</h2><p id="370b2a04-7d46-42a3-bc7b-8bc14c7fe451" class="">
</p><h3 id="77e99ddf-7569-4ba2-a31f-740ef0a511cc" class=""><mark class="highlight-orange">1. Em que consiste realocação dinâmica? Como ela funciona? Quais são as funcionalidades de hardware necessárias para que este método possa ser utilizado?</mark></h3><div id="9c9c270d-1839-4124-b4ec-bfed901e0647" class="column-list"><div id="84875b17-a9f6-4836-86c4-a69040111895" style="width:50%" class="column"><p id="64dabb5f-b423-4dd8-b1b2-b457efee4001" class=""> 1.   A <strong>realocação dinâmica</strong> consiste no processo de conversão de espaço de  endereçamento em endereço físico, temos então, a possibilidade de movimentar o espaço de endereçamento. Um ponto interessante é que a realocação poder ser feita mesmo depois que o processo já tenha iniciado o que dá a ela esse nome. Para seu funcionamento, ela precisa de hardware, um registrador chamado <em><strong>base </strong></em>que é usado para transformar endereços virtuais (gerados pelo programa) em endereços físicos e um registrador chamado <strong><em>bounds </em></strong>(ou <em>limits</em>) que garante que esses endereços estão dentro dos limites do espaço de endereçamento. Tais
registradores são armazenados no MMU (Memory Management Unit) parte do
processador que ajuda na tradução do endereço de memória.</p><p id="bb33b449-d33c-45bd-b01f-6a731ed4405c" class="">
</p><p id="d8e63eb6-7c64-4944-9eec-fbacde0a9a1b" class="">
</p><p id="06328f06-faac-47c3-9338-28e7785dd2d2" class="">
</p><h3 id="da5cbaa7-c159-4ef9-b708-5dacb977d6fa" class=""><mark class="highlight-orange">2. Como se dá o fluxo da Limited Direct Execution Protocol (Dynamic Relocation)?</mark></h3></div><div id="46402f16-3d21-4595-be7e-3ea88ed00cb3" style="width:50%" class="column"><figure id="d9de7323-b1f1-47c9-878c-c3a3831f4868" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2034.png"><img style="width:819px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2034.png"/></a></figure><figure id="87065458-d9f5-4c54-8572-9c7944a37453" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2035.png"><img style="width:860px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2035.png"/></a></figure><p id="2fe23e53-393e-4a39-bf6c-85dd1f6a22f4" class="">
</p></div></div><p id="dfa68455-d564-4ea8-aa7e-64dcdd24387b" class="">
</p><div id="b370d30f-4447-4efc-a873-1e4f2e36c77c" class="column-list"><div id="39e62aa4-cef3-4513-a0f7-f01f6990e45a" style="width:50%" class="column"><p id="c6ff9d3d-9653-4cf3-90d8-6a3426319cb6" class="">2.  Ao bootar, primeiro ocorre a inicialização da <em>trap table</em>, depois, o hardware salva os endereços para os <em>handlers </em>(<em>system call, timer</em>,<em> illegal mem-access</em> e<em> illegal instruction</em>), após isso, inicia-se o <em>interrupt </em>timer, iniciando o timer a cada X ms. Por fim, temos a inicialização da <em>process table</em> e da <em>free list</em> para os processos. Depois, o S.O precisa alocar espaço para um processo, setar os registradores base e bound e executar uma return-from-trap. Em seguida, ele restaura os registradores do processo, entra em user mode, realiza outras instruções com o registrador PC e inicia o processo, que vai buscar e executar suas instruções. Por fim, caso não haja swiches entre processos, o processo executará até o final, onde sua memória será desalocada e sua entrada na lista de processos será apagada.</p><p id="68169b87-01ef-428b-bc92-ff7dbd5e6d6c" class="">
</p></div><div id="fd43c481-a2bf-44b9-b341-d869de99bfb7" style="width:50%" class="column"><figure id="e12a0257-d299-460c-a644-915ddbaef505" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2036.png"><img style="width:655px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2036.png"/></a></figure></div></div><h2 id="a96d9ea9-9bda-458c-bffd-b0b2a4b96c51" class="block-color-yellow_background">16) Segmentation</h2><p id="b885ebdc-e33c-4022-bb41-e6a8988c804b" class="">
</p><h3 id="2ebacefb-8aff-4766-b8ff-a7c46014c7fd" class=""><mark class="highlight-orange">1. Qual a razão para se utilizar segmentação?</mark></h3><div id="0dbe3dea-fd02-4128-a4ac-f9c88a4eac56" class="column-list"><div id="8acaa240-c4dd-4069-8c41-39b8074e145f" style="width:50%" class="column"><ol id="5d27b7dc-8fd9-4dd0-88f0-522af162d7eb" class="numbered-list" start="1"><li>Utilizando uma arquitetura de memória mais simples, pode-se notar uma grande quantidade de memória desperdiçada entre a stack e heap e o motivo de se usar segmentação é solucionar o problema de programas que, sem segmentação, necessitariam de todo o espaço de endereçamento residente na memória e com a criação dos segmentos lógicos esse desperdício é evitado.</li></ol><p id="dbf59613-3c01-466d-9e4b-1ccdd6f69e60" class="">
</p><p id="11b0b9d0-3178-4374-8f81-be574b4f1d58" class="">
</p><p id="ca75f553-fed0-492f-8615-e08691466ebf" class="">
</p><p id="cb7efe41-108c-4219-8cb9-e8a5e9410219" class="">
</p><p id="ab28ced6-11bf-4b9c-9513-5f133efb7cab" class="">
</p><p id="5b02655f-34e3-4961-856a-1eb342045eff" class="">
</p><p id="e6e1c939-f139-4316-bec3-8139f4e31541" class="">
</p><h3 id="e977a98a-7f77-45e5-93ef-f44a73beb1e9" class=""><mark class="highlight-orange">2. Como se define qual o segmento utilizado a partir de um endereço dado?</mark></h3><p id="f1857f66-d5b4-4b2f-ae8d-c3981d866b6a" class="">
</p></div><div id="085adb44-3584-4b7d-880d-3aa6003c5e05" style="width:50%" class="column"><figure id="c0519a7d-6d50-4bf5-aa60-1730f2da2376" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2037.png"><img style="width:1051px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2037.png"/></a></figure></div></div><p id="e736c822-6fe1-4200-bcfc-e004c34ffc29" class="">2.    Podemos definir o o segmento utilizado com base no endereço das seguintes formas:</p><div id="30689724-8163-44ee-a610-1145e9ce531b" class="column-list"><div id="b963bfd5-afe5-4ca7-8222-56bb934c800f" style="width:50%" class="column"><ul id="3ea571d6-fece-4e82-860a-99406ece6571" class="bulleted-list"><li>Explícita - Alocando-se alguns bits mais significativos do endereço para indiciar o segmento referente. Para separar entre código, heap e stack precisaríamos de dois bits, contudo, alguns sistemas, para evitar desperdício, colocam o código no mesmo segmento heap para poderem utilizar apenas um bit como indicador.</li></ul></div><div id="595591e3-3f8f-41e4-9402-10e167bb67e6" style="width:50%" class="column"><figure id="7c65a261-5186-48f7-a820-a6419c6cf6c5" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2038.png"><img style="width:847px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2038.png"/></a></figure></div></div><div id="8990bbab-60a5-4bd5-b5ca-a2416c94404f" class="column-list"><div id="335a2223-c302-4c9a-ab00-3619549fc3d6" style="width:50%" class="column"><ul id="ee9e29ea-0e56-4530-9675-47c430de511a" class="bulleted-list"><li>Implícita - O hardware determina o segmento notando de que forma o endereço foi formado. Se foi gerado pelo program counter → o endereço está dentro do segmento de código, se o endereço é baseado na stack ou base pointer, deve estar dentro do segmento stack, quaisquer outros endereços devem estar no heap.</li></ul></div><div id="482a7142-1982-47cf-b446-70d05d4181ea" style="width:50%" class="column"><figure id="c36df446-9cd7-45c4-9041-cea4849b01b8" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2039.png"><img style="width:864px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2039.png"/></a></figure><figure id="bb4b1744-9fee-47d0-8b2f-0cf3a765ceb4" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2040.png"><img style="width:855px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2040.png"/></a></figure><p id="4dbc8db4-5242-4bdf-a520-19993e4e0ad9" class="">
</p></div></div><p id="47283153-69ba-4079-ad2b-b061f3d7ec59" class="">
</p><h2 id="d8764615-6c02-48db-9fda-42aed7c639a8" class="block-color-yellow_background">17)  Free Space Management</h2><p id="dfec8e31-4310-4bbf-a5d7-cc006b6a6f1f" class="">
</p><h3 id="a3ed75cf-2a5f-4fb1-b225-2f46800797ef" class=""><mark class="highlight-orange">1. Quais as estruturas de dados utilizadas para gerenciar espaços livres em memória?</mark></h3><p id="e98adad4-15c8-4052-b6e3-6d157e2476b7" class="">
</p><div id="dcdd5ef0-0ff0-4b4c-8d33-b612cfe27eb6" class="column-list"><div id="83523284-57af-4709-a17e-b020b549669e" style="width:50%" class="column"><p id="b4875051-bed2-4d76-b99e-9e846cb0eb32" class="">1.   Para gerenciar os espaços livres em memória são usadas listas (<em>free lists</em> ou <em>segregated lists</em>) que vão conter referências para todos os blocos de espaço livre na região controlada da memória. Para mapear os espaços livres a lista deve conter basicamente o endereço de início e tamanho desse espaço, caso uma memória seja solicitada o lista efetuará o chamado “spliting” e achará um chunk suficiente e dividi-lo em dois. Quando algum chunk for liberado, checam-se os vizinhos e caso eles estejam livres também, ocorre a fusão, efeito chamado &quot;colaescing&quot;</p><p id="5c3c3e75-4d7d-4142-8e46-be23cc304851" class="">
</p><h3 id="bc9f5e9e-b54c-4269-857c-69c11860a4d7" class=""><mark class="highlight-orange">2. Em caso de utilização de lista de livres, onde esta pode ser armazenada? Como funciona este armazenamento?</mark></h3><p id="160f9937-7c84-451c-bfbf-1c3294be3b1c" class="">
</p></div><div id="e0bac2a0-fd1e-461c-bb17-4b0dcc7f0c49" style="width:50%" class="column"><figure id="80daab7f-ffc3-4e08-b668-b82ed1be7569" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2041.png"><img style="width:691px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2041.png"/></a></figure></div></div><div id="3d030f80-8739-4430-b881-f35734ea72b3" class="column-list"><div id="68a08235-f745-4788-af5f-e2342be2471f" style="width:50%" class="column"><p id="034cef4f-6e9b-4d84-839d-a727a4311a3f" class="">2.    As listas livres serão armazenadas no próprio <strong>espaço livre</strong>, dentro da memória. O <em>header</em>, minimamente, guarda o tamanho da região alocada e pode conter informação adicional para agilizar procedimentos. A lista é inicializada
de forma que cada elemento terá um endereço , tamanho e apontará para o próximo elemento, para iniciar a lista deve utilizar a system call mmap() , utilizada para retornar
um ponteiro para um espaço vazio.</p><p id="4c80b684-d688-4110-b364-70bcbcd24f7b" class="">
</p><p id="fe5b58ec-78f6-4798-af53-fcf8a89a6f6a" class="">
</p><h3 id="ed023412-c47a-4840-9947-74dc84559a29" class=""><mark class="highlight-orange">3. Quais os algoritmos utilizados para se alocar um processo em um pedaço de memória? Como eles funcionam?</mark></h3></div><div id="37db05c2-62f0-4be4-ad2a-f9ccb4078c2a" style="width:50%" class="column"><figure id="b30f21ec-674e-40b1-8d0d-d74d051a8e04" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2042.png"><img style="width:757px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2042.png"/></a></figure><p id="610035cc-5132-42ed-9813-532d8a0e0efd" class="">
</p></div></div><p id="65a52070-28d2-4489-9ed2-8da3d62cccf3" class="">
</p><p id="ed911b3c-237c-4e50-b49f-8ac3d47fea7c" class="">3. </p><div id="95ff4543-7870-497c-932f-a13366796823" class="column-list"><div id="f1f556fd-65aa-4412-82f1-ed22c8b3eec1" style="width:50%" class="column"><ul id="23153662-66e2-4b7f-bd72-5032b133a927" class="bulleted-list"><li><strong>Best Fit</strong> - Primeiro, procure através da lista livre e encontre os blocos de memória livre que são tão grandes quanto ou maiores que o requisitado, retorne o menor do grupo de candidatos</li></ul></div><div id="2ded7a32-a4ea-4ca6-a552-09fc162d8c58" style="width:50%" class="column"><figure id="59338de5-90b4-4369-a5ba-80fca5c4b765" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2043.png"><img style="width:724px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2043.png"/></a></figure></div></div><div id="d3869d08-4cae-4990-9495-ff9ede13b3c7" class="column-list"><div id="039f544c-a566-40ed-bf5a-58872b4a127d" style="width:50%" class="column"><ul id="18c5b049-2240-4ee2-a021-a6af8f172463" class="bulleted-list"><li><strong>Worst Fit</strong> - O oposto da Best Fit, encontre os maiores blocos de memória livre e retorne o maior</li></ul></div><div id="30f3c1fd-103a-4b51-a67a-3c0fd0b5fd8f" style="width:50%" class="column"><figure id="8daa562d-8647-4486-804d-14e0b19b1f94" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2044.png"><img style="width:766px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2044.png"/></a></figure></div></div><div id="a25004c2-cf38-49f6-b361-28500b84bb9f" class="column-list"><div id="51c17b45-2e26-4eb0-aae5-4f012802cdce" style="width:50%" class="column"><ul id="a46ed0e2-ead8-415c-91cb-7fe0fddec85a" class="bulleted-list"><li><strong>First Fit</strong> - Encontra o primeiro bloco que é grande o suficiente e retorna a quantidade necessária ao usuário</li></ul></div><div id="f2b3cde9-2260-45fc-a3b5-d887a5896403" style="width:50%" class="column"><figure id="a99644de-4a5e-46df-8569-f5ce62c74396" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2045.png"><img style="width:739px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2045.png"/></a></figure></div></div><div id="ee189d3b-15d4-4311-b6e8-ac50cfbfccf1" class="column-list"><div id="5dc98018-8230-4440-a832-19ced9b3ee74" style="width:50%" class="column"><ul id="e55ee5bd-6ef6-4fd5-94db-d3b49fabd6d6" class="bulleted-list"><li><strong>Next Fit </strong>- Ao invés de sempre começar no primeiro, o algorítimo next fit mantém um ponteiro extra, a ideia é procurar mais uniformemente.</li></ul><p id="ad281dba-7bbb-4a73-b280-31cdb4abe25f" class="">
</p><p id="59c5f2ab-6a91-4ed0-87bd-24eb377cbe87" class="">
</p><p id="ebe9c6ec-470a-47e9-ba51-c81c63b3420e" class="">
</p><p id="2f609401-e993-4cd6-964d-d7e4669b34fc" class="">
</p><p id="af22d796-da5c-4f1a-bf25-fe12ea40f564" class="">
</p><p id="03c171f2-37dc-44d2-843d-7ac07a9b8a17" class="">Existem, além desses, outros algoritmos possíveis, esses são:</p><p id="af02f7b7-04ab-4c29-998b-efb445a545f1" class="">
</p><p id="31f93db2-2fce-48c2-bd9b-6f02ba12efe6" class="">
</p><ul id="9626fefc-7c36-4145-b123-502d70da0370" class="bulleted-list"><li><strong>Segregated Lists</strong> - Onde caso uma aplicação tenha uma requisição que seja feita constantemente , uma lista é separada para atribuir objetos daquele tamanho específico , todas outras requisições são encaminhadas para uma lista mais geral.</li></ul><p id="4b98329c-32e9-4e37-ac67-e62e01ce9eac" class="">
</p><p id="5009971e-1417-4c82-aa90-c56a3f58af4e" class="">
</p><p id="7409f44b-a88e-4fee-a601-c6e1d624e0f3" class="">
</p><p id="10349f93-0d97-4290-8936-b5f60432eca6" class="">
</p><p id="123b8519-5291-4c7a-a72d-181775154d20" class="">
</p><p id="bfacde8c-07f8-4dc2-90cd-05b1cc333293" class="">
</p><ul id="91b6b8b6-bccb-4f16-a460-2355a46f3865" class="bulleted-list"><li><strong>Buddy Alocation</strong> - Quando uma requisição de memória é feita, a busca por espaço livre recursivamente divide o espaço por dois até obter o menor bloco que possa alocar o espaço solicitado.</li></ul></div><div id="983a173e-30bb-459f-a23c-7424ecb0170b" style="width:50%" class="column"><figure id="8c5005ae-6774-44fd-8b2d-ebe01b4118ac" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2046.png"><img style="width:716px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2046.png"/></a></figure><p id="a00ba092-8ef3-4ada-8be4-8f36357cac9a" class="">
</p><figure id="f442817b-604a-4d9a-bc36-a07f26f6960f" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2047.png"><img style="width:743px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2047.png"/></a></figure><p id="78726134-f151-44f0-8222-410829bb0eeb" class="">
</p><figure id="93db9d76-6305-4dd0-9986-b3d8b56e7aa1" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2048.png"><img style="width:738px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2048.png"/></a></figure></div></div><p id="428e7876-592a-4549-8916-94d7045aef21" class="">
</p><blockquote id="28891d5c-4167-471e-a4b8-50c1b9b3768e" class=""><strong><em>FIM DO CONTEÚDO DA P1</em></strong></blockquote><hr id="72b3e847-8672-4bf0-abcf-383b18b35684"/><figure id="b12f8b01-0193-47d0-988a-69393beba310"><div class="block-color-blue_background source"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/SO_Semana4.pdf">https://s3-us-west-2.amazonaws.com/secure.notion-static.com/01c810ea-5669-471f-a0a4-309df49cbd68/SO_Semana4.pdf</a></div></figure><h3 id="db3b4965-6ec7-4fbb-a5e5-c614bfb7cf09" class="block-color-yellow_background">18) Introduction to Paging</h3><div id="5545c784-c166-4ed3-b651-0183539f55fc" class="column-list"><div id="f348ea42-7ee1-4cd9-aea5-460eb63bf6c3" style="width:50%" class="column"><p id="60834d39-4873-4abe-a700-a47ec16ab87a" class="">1.   Páginas são unidades de tamanho fixo do espaço de endereçamento, page-frames são slots de tamanho fixo que compõem a memória física.</p><p id="85d15385-a81c-4538-b521-fbbfb78b2880" class="">
</p></div><div id="0c79a87a-634b-4151-b8b5-7a08169bf6a7" style="width:50%" class="column"><figure id="4e811ca9-6958-4819-9d4e-c6863b2e6cb3" class="image"><a href="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2049.png"><img style="width:744px" src="Resumo%20S%20O%2079925d0fe6b540ecb76ab51aa48f28ec/Untitled%2049.png"/></a></figure></div></div><p id="f8ea1147-0167-4e6d-a18b-c3a813bac4b3" class="">2.   Para gravar onde cada página virtual do endereço de espaçamento é colocada, o S.O salva uma page table, que tem como função principal guardar traduções de endereço para cada página virtual. Para traduzir, temos dois componentes:</p><ul id="f18c051e-56e6-4832-add9-ac084c624e54" class="bulleted-list"><li>Virtual Page Number (VPN)</li></ul><ul id="39839187-5726-4490-9ecc-4d8dd7ea5a92" class="bulleted-list"><li>Offset</li></ul><p id="b58d3c1e-7040-44c6-aca0-43b1750f12dc" class="">
</p></div></article></body></html>